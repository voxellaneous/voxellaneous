# Voxellaneous Report (RU)

## Общее описание
Репозиторий разделён на две части:

- `voxellaneous-core/` — ядро рендера на Rust → WASM с `wgpu`.
- `voxellaneous-web/` — веб‑фронтенд на Vite + TypeScript, который поднимает рендер, создаёт сцену и GUI.

### Сборка/запуск
- Ядро (WASM): `wasm-pack build --target web`
- Веб: `npm install`, `npm run dev`

### Поток данных
- TS создаёт `Scene` (палитра + объекты) и вызывает `renderer.upload_scene(scene)`.
- Rust упаковывает палитру в uniform, а воксели загружает в 3D‑текстуры по объектам.
- Рендер‑цикл пишет per‑frame uniform, рисует G‑Buffer, затем выводит выбранный G‑Buffer через full‑screen pass.

## Текущие проблемы / риски

### 1) Загрузка 3D‑текстур нарушает требование `bytes_per_row`
**Где**: `voxellaneous-core/src/lib.rs` в `upload_scene`, `queue.write_texture(...)`.

**Почему это проблема**: WebGPU требует, чтобы `bytes_per_row` был кратен 256. Сейчас используется `bytes_per_row: Some(nx)`, где `nx` — ширина воксельного объёма. В демонстрационной сцене размеры 10/80/100 не кратны 256, что нарушает требования.

**Эффект**: Загрузка может быть отвергнута драйвером или привести к некорректному рендеру.

**Как исправить**: Делать паддинг строк до 256 байт и загружать через staging buffer (или `copy_buffer_to_texture`).

---

### 2) Отображение depth‑буфера некорректно
**Где**:
- `voxellaneous-core/src/lib.rs` (создание depth и present pass).
- `voxellaneous-core/src/shaders/quad_float.wgsl`.

**Почему это проблема**:
- Depth‑текстура создана только с `RENDER_ATTACHMENT`, но затем читается, что требует `TEXTURE_BINDING`.
- Depth нельзя корректно читать как `texture_2d<f32>` с обычным sampler.

**Эффект**: При `presentTarget = 3` будет ошибка валидации или чёрный экран.

**Как исправить**: Создать отдельный pipeline для depth (`texture_2d_depth` + comparison sampler) или копировать depth в float‑текстуру перед показом. Обновить usage‑флаги.

---

### 3) Лимит шагов ray‑march может быть недостаточным
**Где**: `voxellaneous-core/src/shaders/shader.wgsl`, `MAX_STEPS = 256`.

**Почему это проблема**: Для диагональных лучей в объёмах ~100³ может потребоваться больше 256 шагов. Это вызовет преждевременный выход и пропуски геометрии.

**Эффект**: Визуальные артефакты при некоторых ракурсах.

**Как исправить**: Увеличить лимит или вычислять разумный верхний предел по размеру объёма и направлению луча.

---

### 4) Скорость камеры зависит от FPS
**Где**: `voxellaneous-web/src/camera.ts`.

**Почему это проблема**: Движение камеры на фиксированную величину за кадр делает скорость разной на разных машинах.

**Эффект**: Нестабильная и непредсказуемая скорость перемещения.

**Как исправить**: Умножать скорость на delta time (секунды между кадрами).

---

### 5) Аллокации bind‑group каждый кадр
**Где**: `voxellaneous-core/src/lib.rs`, `render()`.

**Почему это проблема**: `per_frame_bind_group` и `quad_bind` создаются каждый кадр, что даёт лишние аллокации.

**Эффект**: Лишняя нагрузка и потенциальная деградация FPS на слабых системах.

**Как исправить**: Кэшировать bind‑groups, обновляя только буферы.

---

### 6) Нет проверки консистентности данных сцены
**Где**: `voxellaneous-core/src/lib.rs` в `upload_scene`.

**Почему это проблема**: Не проверяется соответствие `voxels.len()` размерам `dims`, а также корректность индексов палитры.

**Эффект**: Некорректная загрузка данных, возможные ошибки рендера.

**Как исправить**: Добавить валидацию перед загрузкой и возвращать ошибку в JS.

---

### 7) Потенциальный риск несоответствия layout палитры
**Где**:
- `voxellaneous-core/src/lib.rs`: `StaticUniforms { color_palette: [u32; 256] }`.
- `voxellaneous-core/src/shaders/shader.wgsl`: `palette: array<vec4<u32>, 64>`.

**Почему это риск**: Это совпадает по размеру (64×4=256), но зависит от конкретных правил выравнивания и упаковки.

**Эффект**: Потенциальная порча цветов при изменениях структуры.

**Как исправить**: Зафиксировать layout в документации или привести host‑данные к структуре `vec4<u32>`.

---

### 8) Нет автоматических тестов
**Где**: весь репозиторий.

**Почему это проблема**: Нет тестов/CI, которые ловили бы регрессии в сцене или рендере.

**Эффект**: Ошибки обнаруживаются только вручную.

**Как исправить**: Добавить минимальные тесты генерации сцены и проверки консистентности данных.

## Краткий разбор модулей

### `voxellaneous-core/`
- `Renderer` создаёт device/surface, G‑Buffer, pipeline и рендерит объекты.
- Воксельные объекты рендерятся через ray‑march в `shader.wgsl`.
- `quad_float.wgsl` и `quad_uint.wgsl` отвечают за показ целевого буфера на экран.

### `voxellaneous-web/`
- `main.ts` поднимает WASM, создаёт камеру, запускает rAF‑цикл.
- `camera.ts` реализует pointer‑lock управление.
- `editor.ts` + `renderer/editor.ts` дают UI для выбора G‑Buffer и просмотра данных GPU.
- `tests/cornell-box.ts` генерирует тестовую сцену (Cornell box).

### `ai-development-framework/`
- Жёстко регламентирует процесс разработки стадиями и логированием.

## Дополнительные заметки
- `README.md` минимален, предполагает ручной порядок сборки.
- Vite‑конфиг расширяет доступ к корню репозитория для подключения локального WASM.

